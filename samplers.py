"""
This file contains the class definition for the sampler MCMCSample classes.
"""

__author__ = 'Brandon C. Kelly'

import numpy as np
import progressbar
from matplotlib import pyplot as plt
from statsmodels.tsa import arima_process, arima_model


class MCMCSample(object):
    """
    Class object for parameter samples generated by a MCMC sampler. This class contains a dictionary of samples
    generated by an MCMC sampler for a set of parameters, as well as methods for plotting and summarizing the results.

    In general, the MCMCSample object is empty upon instantiation. One adds parameters to the dictionary through the
    AddStep method of a Sampler object. Running a Sampler object then fills the dictionary up with the parameter values.
    After running a Sampler object, the MCMCSample object will contain the parameter values, which can then be analyzed
    further.

    Alternatively, one can load the parameters and their values from a file. This is done through the method
    generate_from_file. This is helpful if one has a set of MCMC samples generated by a different program.
    """

    def __init__(self, filename=None):
        """
        Constructor for an MCMCSample object. If no arguments are supplied, then this just creates an empty dictionary
        that will contain the MCMC samples. In this case parameters are added to the dictionary through the addstep
        method of a Sampler object, and the values are generated by running the Sampler object. Otherwise, if a
        filename is supplied then the parameter names and MCMC samples are read in from that file.

        :param filename: A string giving the name of an asciifile containing the MCMC samples.
        """
        self._samples = dict()  # Empty dictionary. We will place the samples for each tracked parameter here.
        if filename is not None:
            # Construct MCMCSample object by reading in MCMC samples from an asciifile.
            self.generate_from_file(filename)

    def addparameter(self, name, values_array):
        """
        Add an array of parameter values to the dictionary of samples.

        :param name: The name of the parameter. This will be used for the dictionary key associated with this parameter.
        :param values_array: A numpy array object for holding the samples for each parameter.
        """
        if name not in self._samples:
            # Parameter is not already in the dictionary, so add it. Otherwise do nothing.
            self._samples[name] = values_array

    def get_samples(self, name):
        """
        Returns a copy of the numpy array containing the samples for a parameter. This is safer then directly
        accessing the dictionary object containing the samples to prevent one from inadvertently changes the values of
        the samples output from an MCMC sampler.

        :param name: The name of the parameter for which the samples are desired.
        """
        return self._samples[name].copy()

    def generate_from_file(self, filename):
        """
        Build the dictionary of parameter samples from an ascii file of MCMC samples. The first line of this file
        should contain the parameter names.

        :param filename: The name of the file containing the MCMC samples.
        """
        pass

    def autocorr_timescale(self, trace, order=(1, 0)):
        """
        Compute the autocorrelation time scale using an ARMA(p,q) model.

        :param trace: The parameter trace, a numpy array.
        :param order: The order of the ARMA(p,q) model, a tuple.
        """
        arma_model = arima_model.ARMA(trace, order=order)
        print "Getting model ACF for calculating the autocorrelation timescale..."
        arma_result = arma_model.fit(disp=-1)

        # Grab the estimated values of the AR and MA coefficients
        arcoefs = np.ones(order[0] + 1)
        macoefs = np.ones(order[1] + 1)
        # Need to convert the output to the input expected when computing the model autocorrelation function.
        arcoefs[1:] = -1.0 * arma_result.arparams
        macoefs[1:] = arma_result.maparams

        # Compute the model ACF
        model_acf = arima_process.arma_acf(arcoefs, macoefs, trace.size)

        acf_timescale = model_acf[0] + 2.0 * model_acf[1:].sum()
        return acf_timescale

    def effective_samples(self, name):
        """
        Return the effective number of independent samples of the MCMC sampler.

        :param name: The name of the parameter to compute the effective number of independent samples for.
        """
        traces = self._samples[name]  # Get the sampled parameter values

        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            acf_timescale = self.autocorr_timescale(traces)
            nsamples_effective = traces.size / acf_timescale
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            nsamples_effective = np.zeros(traces.shape[1])

            traces = traces - traces.mean(axis=0)

            for i in xrange(traces.shape[1]):
                acf_timescale = self.autocorr_timescale(traces[:, i])
                nsamples_effective[i] = traces.shape[0] / acf_timescale

        return nsamples_effective

    def plot_trace(self, name):
        """
        Plot the trace of the values, a time series showing the evolution of the parameter values for the MCMC sampler.
        Only a single parameter element trace is shown per plot, and all plots are shown on the same plotting window. In
        particular, if a parameter is array-valued, then the traces for each element of its array are plotted on a
        separate subplot.

        :param name: The parameter name.
        """
        traces = self._samples[name]  # Get the sampled parameter values
        if traces.ndim == 1:
            # Parameter is scalar valued, so just make a single trace plot
            plt.plot(traces, '.')
            plt.title(name)
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # Plot each element of this parameters' elements separately
                plt.subplot(traces.shape[1], 1, i + 1)
                plt.plot(traces[:, i], '.', markersize=2)
                if i == 0:
                    # Add plot title
                    plt.title(name)

        plt.show()

    def plot_1dpdf(self, name):
        """
        Plot histograms of the parameter values generated by the MCMC sampler. If the parameter is array valued then
        histograms of all of the parameter's elements will be plotted.

        :param name: The parameter name.
        """
        traces = self._samples[name]  # Get teh sampled parameter values
        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            plt.hist(traces, bins=50, normed=True)
            plt.title(name)
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # Plot each element of this parameters' elements separately
                npanels = int(np.sqrt(traces.shape[1])) + 1
                plt.subplot(npanels, npanels, i + 1)
                plt.hist(traces[:, i], bins=50, normed=True)
                if i == 0:
                    # Add plot title
                    plt.title(name)

        plt.show()

    def plot_autocorr(self, name):
        """
        Plot the autocorrelation functions of the traces for a parameter. If the parameter is array-value then
        autocorrelation plots for each of the parameter's elements will be plotted.

        :param name: The parameter name.
        """
        traces = self._samples[name]  # Get the sampled parameter values

        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            centered_trace = traces - traces.mean()
            lags, acf, not_needed1, not_needed2 = plt.acorr(centered_trace, maxlags=traces.size, lw=2)
            acf = acf[acf.size / 2:]
            lags = lags[lags.size / 2:]
            # Compute the autocorrelation time scale and then resize the plot
            acf_timescale = self.autocorr_timescale(traces)
            plt.xlim(0, 5.0 * acf_timescale)
            plt.title(name)
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # Plot each element of this parameter separately
                plt.subplot(traces.shape[1], 1, i + 1)
                centered_trace = traces[:, i] = np.mean(traces[:, i])
                lags, acf, not_needed1, not_needed2 = plt.acorr(centered_trace, maxlags=traces.shape[0], lw=2)
                acf = acf[acf.size / 2:]
                lags = lags[lags.size / 2:]
                # Compute the autocorrelation time scale and then resize the plot
                acf_timescale = self.autocorr_timescale(traces[:, i])
                plt.xlim(0, 5.0 * acf_timescale)
                if i == 0:
                    # Add plot title
                    plt.title(name)

        plt.show()

    def plot_parameter(self, name, pindex=0):
        """
        Simultaneously plots the trace, histogram, and autocorrelation of this parameter's values. If the parameter
        is array-valued, then the user must specify the index of the array to plot, as these are all 1-d plots on a
        single plotting window.

        :param name: The name of the parameter that the plots are made for.
        :param pindex: If the parameter is array-valued, then this is the index of the array that the plots are made
                       for.
        """
        traces = self._samples[name]
        plot_title = name
        if traces.ndim > 1:
            # Parameter is array valued, grab the column corresponding to pindex
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))
            traces = traces[:, pindex]
            plot_title = name + ", element " + str(pindex)

        # First plot the trace
        plt.subplot(211)
        plt.plot(traces, '.', markersize=2)
        plt.xlim(0, traces.size)
        plt.xlabel("Iteration")
        plt.ylabel("Value")
        plt.title(plot_title)

        # Now add the histogram of values to the trace plot axes
        pdf, bin_edges = np.histogram(traces, bins=25)
        bin_edges = bin_edges[0:pdf.size]
        # Stretch the PDF so that it is readable on the trace plot when plotted horizontally
        pdf = pdf / float(pdf.max()) * 0.34 * traces.size
        # Add the histogram to the plot
        plt.barh(bin_edges, pdf, height=bin_edges[1] - bin_edges[0], alpha=0.75)

        # Finally, plot the autocorrelation function of the trace
        plt.subplot(212)
        centered_trace = traces - traces.mean()
        lags, acf, not_needed1, not_needed2 = plt.acorr(centered_trace, maxlags=traces.size - 1, lw=2)
        acf = acf[acf.size / 2:]
        plt.ylabel("ACF")
        plt.xlabel("Lag")

        # Compute the autocorrelation timescale, and then reset the x-axis limits accordingly
        acf_timescale = self.autocorr_timescale(traces)
        plt.xlim(0, 5.0 * acf_timescale)
        plt.show()

    def posterior_summaries(self, name):
        """
        Print out the posterior medians, standard deviations, and 68th, 95th, and 99th credibility intervals.

        :param name: The name of the parameter for which the summaries are desired.

        See the documentation for MCMCSample.plot_trace for further information.
        """
        traces = self._samples[name]  # Get the sampled parameter values
        effective_nsamples = self.effective_samples(name)  # Get the effective number of independent samples
        if traces.ndim == 1:
            # Parameter is scalar valued, so this is easy
            print "Posterior summary for parameter", name
            print "----------------------------------------------"
            print "Effective number of independent samples:", effective_nsamples
            print "Median:", np.median(traces)
            print "Standard deviation:", np.std(traces)
            print "68% credibility interval:", np.percentile(traces, (16.0, 84.0))
            print "95% credibility interval:", np.percentile(traces, (2.5, 97.5))
            print "99% credibility interval:", np.percentile(traces, (0.5, 99.5))
        else:
            if traces.ndim > 2:
                # Parameter values are at least matrix-valued, reshape to a vector.
                traces = traces.reshape(traces.shape[0], np.prod(traces.shape[1:]))

            for i in xrange(traces.shape[1]):
                # give summary for each element of this parameter separately
                # Parameter is scalar valued, so this is easy
                print "Posterior summary for parameter", name, " element", i
                print "----------------------------------------------"
                print "Effective number of independent samples:", effective_nsamples[i]
                print "Median:", np.median(traces[:, i])
                print "Standard deviation:", np.std(traces[:, i])
                print "68% credibility interval:", np.percentile(traces[:, i], (16.0, 84.0))
                print "95% credibility interval:", np.percentile(traces[:, i], (2.5, 97.5))
                print "99% credibility interval:", np.percentile(traces[:, i], (0.5, 99.5))


class Sampler(object):
    """
    A class to generate samples of parameter from their probability distribution. Samplers consist of a series of
    steps, where each step updates the value of the parameter(s) associated with it. The samples for the tracked
    parameters are saved to a MCMCSample object.
    """

    def __init__(self, mcmc_samples, sample_size, burnin, thin=1):
        """
        Constructor for Sampler object.

        :param mcmc_samples: An MCMCSample object. The generated samples are added to this object.
        :param sample_size: The final sample size to generate. A total of burnin + thin * sample_size iterations will
                            be performed.
        :param burnin: The number of burnin iterations to run.
        :param thin: The thinning interval. Every thin iterations will be kept.
        """
        self.sample_size = sample_size
        self.burnin = burnin
        self.thin = thin
        self._steps = []  # Empty list that will eventually contain the step objects.

        # Construct progress bar objects
        self._burnin_bar = progressbar.ProgressBar(maxval=burnin)
        self._sampler_bar = progressbar.ProgressBar(maxval=sample_size)

        self._mcmc_samples = mcmc_samples  # MCMCSample class object. This is where the sampled values are stored.

    def AddStep(self, step):
        """
        Method to add a step object to the sampler. The sampler will iterate over the step objects, calling their
        Draw() method once per iteration. This method will also initialize the parameter value associated with this
        step, and if the parameter is tracked it will add it to the dictionary containing the samples.
        """
        self._steps.append(step)

        # Set initial value of parameter associated with this step.
        step._parameter.SetStartingValue()

        if step._parameter.track:
            # We are saving this parameter's values, so add to dictionary of samples.
            if np.isscalar(step._parameter.value):
                # Parameter is scalar-valued, so this is easy
                value_array = np.empty(self.sample_size)
            else:
                # Parameter is array-like, so get shape of parameter array first
                pshape = step._parameter.value.shape
                trace_shape = (self.sample_size,) + pshape
                # Get numpy array that will store the samples values for this parameter
                value_array = np.empty(trace_shape)
                # Add the array that will hold the sampled parameter values to the dictionary of samples.
            self._mcmc_samples.addparameter(step._parameter.name, value_array)

    def Iterate(self, niter, burnin_stage=True):
        """
        Method to perform niter iterations of the sampler.

        :param niter: The number of iterations to perform.
        :param burnin_stage: Are we in the burn-in stage?
        """
        for i in xrange(niter):
            for step in self._steps:
                step.DoStep()

            if burnin_stage:
                # Update the burn-in progress bar
                self._burnin_bar.update(i + 1)

    def SaveValues(self):
        """
        Save the parameter values. These values are saved in a dictionary of numpy arrays, indexed according to the
        parameter names. The dictionary of samples is accessed as Sampler.samples.
        """
        current_iteration = self._sampler_bar.currval  # Progress bar keeps track of how many iterations we have run
        for step in self._steps:
            # Save the parameter value associated with each step.
            if np.isscalar(step._parameter.value):
                # Need to treat scalar case separately
                self._mcmc_samples._samples[step._parameter.name][current_iteration] = step._parameter.value
            else:
                # Have a vector- or matrix-valued parameter
                self._mcmc_samples._samples[step._parameter.name][current_iteration, :] = step._parameter.value

    def Run(self):
        """
        Run the sampler.
        """
        # First print out helpful information.
        print "Using", len(self._steps), "steps in the MCMC sampler."
        print "Obtaining samples of size", self.sample_size, "for", len(self._mcmc_samples._samples), "parameters."

        # First do burn-in stage
        print "Doing burn-in stage first..."
        self._burnin_bar.start()
        self.Iterate(self.burnin)  # Perform the burn-in iterations

        # Now run the sampler.
        print "Sampling..."
        self._sampler_bar.start()

        for i in xrange(self.sample_size):
            if self.thin == 1:
                # No thinning is performed, so don't waste time calling self.Iterate.
                for step in self._steps:
                    step.DoStep()

            else:
                # Need to thin the samples, so do thin iterations.
                self.Iterate(self.thin, burnin_stage=False)

            # Now save the tracked parameter values to the samples dictionary object
            self.SaveValues()

            self._sampler_bar.update(i + 1)  # Update the progress bar


    def Restart(self, sample_size, thin=1):
        """
        Restart the MCMC sampler at the current value. No burn-in stage will be performed.
        """
        pass